# spotify-ui-streamlit

A web application built with a Streamlit frontend and a Node.js Express backend that integrates with Spotify's API to showcase personalized user data. The backend handles secure authentication with Spotify and fetches user-specific data, such as playlists, top tracks, favorite artists, and listening habits. This data is then processed and served to the Streamlit frontend, which provides an intuitive and interactive interface for users to explore their Spotify statistics. The platform combines the simplicity of Streamlit's Python-based UI design with the scalability and efficiency of a Node.js backend, delivering a seamless and visually appealing experience.

## Features
- Spotify Authentication: Secure login via Spotify’s OAuth.
- User Data: Display personalized Spotify data, including playlists, top tracks, favorite artists, and listening habits.
- Interactive UI: Built using Streamlit for an intuitive and user-friendly interface.
- Scalable Backend: Node.js Express server handles API calls and data processing.
- Responsive Design: Optimized to deliver a seamless experience across devices.

## Tech Stack
- Frontend: Streamlit (Python)
- Backend: Node.js, Express
- Spotify API: Integration to fetch user-specific data
- Authentication: OAuth 2.0 (via Spotify)
- Cloud Storage: Azure Blob Storage (for data storage and retrieval)

## Deployment to Azure

Both the backend and frontend of this project have been deployed to Azure to provide a seamless experience for users. The backend is hosted on Azure at:

- [Backend](https://spotify-streamlit-backend.azurewebsites.net/)
- [Frontend](https://spotify-streamlit-frontend.azurewebsites.net/)

## Deployment Process

The deployment process for both the backend and frontend is fully automated through a GitHub Actions workflow. Below is a breakdown of the steps involved:

### 1. CI Pipeline: Linting, Testing, and Building

The CI pipeline starts by performing several key actions:

- Linting and Testing: The pipeline first runs linting tools (like yamllint and flake8) to ensure the code quality and compliance with style guidelines. It also runs unit tests using pytest for the frontend and jest for the backend to ensure the system is working as expected.

- Docker Image Creation: Both the frontend and backend are built into Docker containers using the Dockerfile for each. These containers are then pushed to Docker Hub, where they are stored and made available for deployment.

### 2. Deploying to Azure: Backend and Frontend

Once the Docker images are successfully pushed to Docker Hub, both images are deployed to Azure using terraform. The code responsible for this can be found here at [terraform-azure](https://github.com/powellrhys/terraform-azure).

Once deployed, updates to the resources are handled by the final steps within the deployment pipeline. Here both resources are stopped and restarted; ensuring the latest changes get pulled through. 

### 3. Automation with GitHub Actions

The entire deployment pipeline is managed by a GitHub Actions workflow, which is triggered automatically on certain events, such as:

- Push to Feature Branches: The deployment is triggered whenever there is a push to a branch starting with feature/.
- Pull Requests: The workflow also runs when a pull request is opened.

## Frontend Overview

The frontend has been generated by streamlit. The application is made up of 3 pages, a Home page with enables the user to call the backend and update the backend data, a Listening Habit page which displays the user's top tracks and artists for various time periods and an Export Listening Habits page which enables a user to create a new playlist on spotify. 

When viewing the frontend in azure, the user will be prompted to login in. If you are not in possession of the required credentials, here is what both pages look like:

### Login Page

![Screenshot of Login Page](docs/images/login_page.png?raw=true "Login Page")

### Home Page

![Screenshot of Home Page](docs/images/home_page.png?raw=true "Home Page")

### Listening Habits Page

![Screenshot of Listening Habits Page](docs/images/listening_habits_page.png?raw=true "Listening Habits Page")

### Export Listening Habits Page

![Screenshot of Export Listening Habits Page](docs/images/export_listening_habits_page.png?raw=true "Export Listening Habits Page")

## Backend Overview

The backend of this project is built using Node.js and Express, providing a scalable and efficient API for integrating with Spotify and processing user data. It is designed to handle authentication, fetch personalized data from Spotify, and serve it to the frontend (Streamlit app).

### Entry Point: server.js

The entry point of the backend is the server.js file, which sets up the HTTP server and listens for incoming requests. It imports the application logic from the app.js file and configures the server to listen on a defined port (defaulting to 3000 if not specified).

### Application Configuration: app.js

The app.js file sets up the Express application, defining routes and middleware to handle requests. It imports various route modules that handle specific API endpoints for user authentication, Spotify callbacks, retrieving user data, and creating playlists.

### Key Components of the Backend

The backend is built using Express.js, a lightweight web framework for Node.js. Express is used to handle HTTP requests, route traffic, and manage middleware.
Middleware:

The express.json() middleware is used to parse incoming JSON requests. This allows the backend to process requests that include user data or other JSON payloads.

Routes:

- Entry Route (/): Handles general entry points for the API.
- Login Route (/login): Manages the authentication flow with Spotify, directing users to Spotify's OAuth authorization.
- Callback Route (/callback): Handles the callback from Spotify after authentication and processes the authorization code.
- Top Tracks Route (/top): Fetches and serves data on the user's top tracks from Spotify.
- Create Playlist Route (/createplaylist): Allows users to create new playlists on their Spotify account.

### Separation of Concerns:

Each route is modularized into separate files under the api/routes/ directory, making the codebase organized and maintainable. These route files handle specific API logic, like processing requests and interacting with Spotify's API.

## Environment Variables

Environment variables play a crucial role in storing sensitive information and configuration settings for the project. These variables are loaded from a .env file using the dotenv package to ensure a secure and configurable application.

### Managing Environment Variables

The project uses a Variables class in Python to handle all the constants and environment variables required for different parts of the application. The environment variables are loaded using the dotenv package to securely retrieve configuration values from a .env file during local development or from the environment in production.

### Environment Variables Explained
Here are the key environment variables used in the project:

#### API Credentials:

- `client_id`: The client ID used to authenticate the application with external services (such as Spotify).
- `client_secret`: The client secret associated with the application for secure authentication.
- `host_url`: The base URL for the API, typically the URL of the backend server.

#### Spotify Credentials:

- `spotify_user_id`: The Spotify user ID used for retrieving user-specific data from the Spotify API.
- `spotify_username`: The username associated with the Spotify account.
- `spotify_password`: The password for the Spotify account (used for secure authentication).

#### Blob Storage:

- `blob_storage_connection_string`: The connection string for accessing Azure Blob Storage, used for storing and retrieving files, such as user data or logs.

#### UI Configuration:

- `login_required`: A flag that determines whether login is required to access certain parts of the application. It defaults to True but can be set to False if login is optional.
- `app_username`: The username for the application’s admin interface (used for authentication).
- `app_password`: The password for the application’s admin interface (used for authentication).

## Code Coverage Reporting with GitHub Actions and Codecov

This repository demonstrates how to use GitHub Actions to automate testing and upload code coverage reports to [Codecov](https://about.codecov.io/).

### Overview
The workflow runs tests for both the frontend and backend of the project, generating code coverage reports. These reports are then uploaded to Codecov for analysis and visualization.

#### Frontend Tests
Frontend tests are executed using `pytest` with coverage reporting enabled. The workflow generates coverage reports in both XML format for Codecov and a terminal output format for quick feedback.

#### Backend Tests
Backend tests are run using `npm test` within the backend directory. Coverage is enabled to ensure the quality of the backend code, and the results are uploaded to Codecov for tracking and analysis.

### Prerequisites

To use this workflow, ensure you have:

1. A Codecov account and an associated repository.
2. A `CODECOV_TOKEN` for authentication, stored as a secret in your GitHub repository.

### Setting Up the Repository

1. Add a Codecov token to your repository's secrets.
2. Install the necessary dependencies for both the frontend and backend testing frameworks.
3. Configure a GitHub Actions workflow to run tests and upload coverage reports.
